data1 = mlbench.cassini(n=100)
data1
# generate two datasets
data1 = mlbench.cassini(n=100)$x
data2 = mlbench.smiley(n=100)$x
# translate
data2[,1] = data2[,1] + 5
# plot the datasets
plot(data1, col="blue", pch=19, cex=0.5, main="Two datasets")
points(data2)
data2
head(data2)
# plot the datasets
plot(data1, col="blue", pch=19, cex=0.5, main="Two datasets")
points(data2)
help(points)
# plot the datasets
plot(data1, col="blue", pch=19, cex=0.5, main="Two datasets")
points(data2[,1], data[,2], col="red", cex=0.5, pch=19)
library(mlbench)
# generate two datasets
data1 = mlbench.cassini(n=100)$x
data2 = mlbench.smiley(n=100)$x
# translate
data2[,1] = data2[,1] + 5
# plot the datasets
plot(data1, col="blue", pch=19, cex=0.5, main="Two datasets")
points(data2[,1], data[,2], col="red", cex=0.5, pch=19)
max(data2[,1])
# plot the datasets
plot(data1, col="blue", pch=19, cex=0.5, main="Two datasets", xlim=c(-1.5, 6))
points(data2[,1], data2[,2], col="red", cex=0.5, pch=19)
help("mlbench.smiley")
pkgdown::build_articles(); pkgdown::preview_site(path='articles/basic_compute_distance.html')
pkgdown::build_articles(); pkgdown::preview_site(path='articles/basic_compute_distance.html')
pkgdown::build_articles(); pkgdown::preview_site
pkgdown::build_articles(); pkgdown::preview_site
pkgdown::build_articles(); pkgdown::preview_site()
pkgdown::build_articles(); pkgdown::preview_site()
pkgdown::build_articles(); pkgdown::preview_site()
pkgdown::build_articles(); pkgdown::preview_site
pkgdown::build_articles(); pkgdown::preview_site()
help("wasserstein")
# call the function
output = wasserstein(data1, data2, p=2)
output
pkgdown::build_articles(); pkgdown::preview_site()
pkgdown::preview_site()
pkgdown::build_articles(); pkgdown::preview_site()
pkgdown::clean_cache()
pkgdown::build_articles()
pkgdown::preview_site()
pkgdown::build_articles(preview=TRUE)
P = output$plan
maxP = max(P)
maxP
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
pkgdown::build_articles(preview=TRUE)
install.packages("proxy")
pkgdown::build_articles(preview=TRUE)
pkgdown::clean_site()
pkgdown::build_site()
pkgdown::build_articles()
pkgdown::build_articles(preview=TRUE)
pkgdown::clean_cache()
pkgdown::build_site()
.Last.error
pkgdown::clean_cache()
pkgdown::build_site()
pkgdown::clean_site()
pkgdown::build_site()
pkgdown::clean_site()
pkgdown::build_site()
pkgdown::build_articles()
pkgdown::clean_site()
pkgdown::clean_cache()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::clean_cache()
pkgdown::clean_site()
pkgdown::build_site()
pkgdown::clean_site()
pkgdown::clean_cache()
pkgdown::build_site()
pkgdown::clean_cache()
pkgdown::clean_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
install.packages("openalexR", dependencies = TRUE)
file.edit("~/.Renviron")
# personal example
# generate "n_good" measures from N(0, I)
#           "n_bad" measures from N(20, I)
n_pts = 30
n_goods = 17
n_bad = 3
input_measures = list()
for (i in 1:n_goods){
input_measures[[i]] = matrix(rnorm(n_pts*2), ncol=2)
}
for (i in (n_goods+1):(n_goods+n_bad)){
translated = matrix(rnorm(n_pts*2), ncol=2)
translated[,1] = translated[,1] + 20
input_measures[[i]] = translated
}
run_bary = rbaryGD(input_measures, num_support = n_pts)
run_median = rmedIRLS(input_measures, num_support = n_pts)
help(rmedIRLS)
help(rbaryGD)
help(rmedIRLS)
# personal example
# generate "n_good" measures from N(0, I)
#           "n_bad" measures from N(20, I)
n_pts = 30
n_goods = 17
n_bad = 3
input_measures = list()
for (i in 1:n_goods){
input_measures[[i]] = matrix(rnorm(n_pts*2), ncol=2)
}
for (i in (n_goods+1):(n_goods+n_bad)){
translated = matrix(rnorm(n_pts*2), ncol=2)
translated[,1] = translated[,1] + 20
input_measures[[i]] = translated
}
run_bary = rbaryGD(input_measures, num_support = n_pts)
run_median = rmedIRLS(input_measures, num_support = n_pts)
base1 = matrix(rnorm(100*2), ncol=2)
base2 = matrix(rnorm(20*2), ncol=2); base2[,1] = base2[,1]+20
base_mat = rbind(base1, base2)
plot(base_mat, col="grey80")
plot(base_mat, col="grey80", pch=19)
base1 = matrix(rnorm(200*2), ncol=2)
base2 = matrix(rnorm(50*2), ncol=2); base2[,1] = base2[,1]+20
base_mat = rbind(base1, base2)
plot(base_mat, col="grey80", pch=19)
abline(h=0); abline(v=0)
points(run_bary$support, col="blue")
points(run_bary$support, col="blue", pch=19)
points(run_median$support, col="red", pch=19)
n_pts = 30
n_goods = 12
n_bad = 8
input_measures = list()
for (i in 1:n_goods){
input_measures[[i]] = matrix(rnorm(n_pts*2), ncol=2)
}
for (i in (n_goods+1):(n_goods+n_bad)){
translated = matrix(rnorm(n_pts*2), ncol=2)
translated[,1] = translated[,1] + 20
input_measures[[i]] = translated
}
run_bary = rbaryGD(input_measures, num_support = n_pts)
run_median = rmedIRLS(input_measures, num_support = n_pts)
graphics.off()
run_bary = rbaryGD(input_measures, num_support = n_pts)
run_median = rmedIRLS(input_measures, num_support = n_pts)
base1 = matrix(rnorm(200*2), ncol=2)
base2 = matrix(rnorm(50*2), ncol=2); base2[,1] = base2[,1]+20
base_mat = rbind(base1, base2)
plot(base_mat, col="grey80", pch=19)
abline(h=0); abline(v=0)
points(run_bary$support, col="blue", pch=19)
points(run_median$support, col="red", pch=19)
run_median$history
## GENERATE DATA
#  8 empirical measures from class 1
input_measures = vector("list", length=10L)
for (i in 1:8){
input_measures[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in 9:10){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 20
input_measures[[j]] = base_draw
}
## COMPUTE
#  compute the Wasserstein median
run_median = rmedIRLS(input_measures, num_support = 50)
#  compute the Wasserstein barycenter
run_bary   = rbaryGD(input_measures, num_support = 50)
#  draw the base points of two classes
base_1 = matrix(rnorm(80*2), ncol=2)
base_2 = matrix(rnorm(20*2), ncol=2)
base_2[,1] = base_2[,1] + 20
base_mat = rbind(base_1, base_2)
plot(base_mat, col="gray80", pch=19)
title(main = expression("Estimated " *
phantom("barycenter") * phantom(" and ") * phantom("median")))
title(main = expression("Estimated " *
phantom("barycenter") * phantom(" and ") * phantom("median")))
title(main = expression("Estimated " *
textstyle(bold(phantom("barycenter")))), col.main="red", line=1.5)
title(main = expression(phantom("Estimated barycenter and ") *
textstyle(bold("median"))), col.main="blue", line=1.5)
title("estimated barycenter and median")
graphics.off()
base_1 = matrix(rnorm(80*2), ncol=2)
base_2 = matrix(rnorm(20*2), ncol=2)
base_2[,1] = base_2[,1] + 20
base_mat = rbind(base_1, base_2)
plot(base_mat, col="gray80", pch=19)
title("estimated barycenter and median")
#  draw the barycenter and the median
points(run_bary$support, col="red", pch=19)
points(run_median$support, col="blue", pch=19)
abline(v=0); abline(h=0)
graphics.off()
unlink(list.dirs("vignettes", recursive = FALSE, full.names = TRUE),
recursive = TRUE, force = TRUE)
unlink(Sys.glob("vignettes/**/*.{html,pdf,RData,rdb,rdx}"), force = TRUE)
list.files("vignettes", recursive = TRUE)
devtools::build_vignettes()
devtools::build_vignettes()
pkgdown::build_site()
pkgdown::clean_site()
pkgdown::build_site()
devtools::build_vignettes()
pkgdown::build_site()
help(rmedIRLS)
help(rbaryGD)
pkgdown::build_site()
n_pts = 10
n_goods = 7
n_bad = 3
input_measures = list()
for (i in 1:n_goods){
input_measures[[i]] = matrix(rnorm(n_pts*2), ncol=2)
}
for (i in (n_goods+1):(n_goods+n_bad)){
translated = matrix(rnorm(n_pts*2), ncol=2)
translated[,1] = translated[,1] + 20
input_measures[[i]] = translated
}
run_bary = rbaryGD(input_measures, num_support = n_pts)
run_medIRLS = rmedIRLS(input_measures, num_support = n_pts)
run_medPF = rmedPF(input_measures, num_support = n_pts)
# plot
base1 = matrix(rnorm(200*2), ncol=2)
base2 = matrix(rnorm(50*2), ncol=2); base2[,1] = base2[,1]+20
base_mat = rbind(base1, base2)
plot(base_mat, col="grey80", pch=19)
abline(h=0); abline(v=0)
points(run_bary$support, col="blue", pch=19)
points(run_medIRLS$support, col="red", pch=19)
points(run_medPF$support, col="green", pch=19)
rm(list=ls())
n_pts = 100
n_goods = 20
n_bad = 10
input_measures = list()
for (i in 1:n_goods){
input_measures[[i]] = matrix(rnorm(n_pts*2), ncol=2)
}
for (i in (n_goods+1):(n_goods+n_bad)){
translated = matrix(rnorm(n_pts*2), ncol=2)
translated[,1] = translated[,1] + 20
input_measures[[i]] = translated
}
microbenchmark::microbenchmark(
run_bary = rbaryGD(input_measures, num_support = n_pts),
run_medIRLS = rmedIRLS(input_measures, num_support = n_pts),
run_medPF = rmedPF(input_measures, num_support = n_pts),
times=3
)
rm(list=ls())
# runtime comparison
# personal example
# generate "n_good" measures from N(0, I)
#           "n_bad" measures from N(20, I)
n_pts = 50
n_goods = 15
n_bad = 5
input_measures = list()
for (i in 1:n_goods){
input_measures[[i]] = matrix(rnorm(n_pts*2), ncol=2)
}
for (i in (n_goods+1):(n_goods+n_bad)){
translated = matrix(rnorm(n_pts*2), ncol=2)
translated[,1] = translated[,1] + 20
input_measures[[i]] = translated
}
microbenchmark::microbenchmark(
run_bary = rbaryGD(input_measures, num_support = n_pts),
run_medIRLS = rmedIRLS(input_measures, num_support = n_pts),
run_medPF = rmedPF(input_measures, num_support = n_pts),
times=3
)
run_medIRLS = rmedIRLS(input_measures, num_support = n_pts),
run_bary = rbaryGD(input_measures, num_support = n_pts)
run_medIRLS = rmedIRLS(input_measures, num_support = n_pts)
run_medPF = rmedPF(input_measures, num_support = n_pts)
# plot
base1 = matrix(rnorm(200*2), ncol=2)
base2 = matrix(rnorm(50*2), ncol=2); base2[,1] = base2[,1]+20
base_mat = rbind(base1, base2)
plot(base_mat, col="grey80", pch=19)
abline(h=0); abline(v=0)
points(run_bary$support, col="blue", pch=19)
points(run_medIRLS$support, col="red", pch=19)
points(run_medPF$support, col="green", pch=19)
rm(list=ls())
# * class 2 : samples from N((20,0), Id)
#
#  We draw 8 empirical measures of size 50 from class 1, and
#  2 from class 2. All measures have uniform weights.
#-------------------------------------------------------------------
## GENERATE DATA
#  8 empirical measures from class 1
input_measures = vector("list", length=10L)
for (i in 1:8){
input_measures[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in 9:10){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 20
input_measures[[j]] = base_draw
}
## COMPUTE
#  compute the Wasserstein median
run_median = rmedPF(input_measures, num_support = 50)
#  compute the Wasserstein barycenter
run_bary   = rbaryGD(input_measures, num_support = 50)
## VISUALIZE
opar <- par(no.readonly=TRUE)
#  draw the base points of two classes
base_1 = matrix(rnorm(80*2), ncol=2)
base_2 = matrix(rnorm(20*2), ncol=2)
base_2[,1] = base_2[,1] + 20
base_mat = rbind(base_1, base_2)
plot(base_mat, col="gray80", pch=19)
#  auxiliary information
title("estimated barycenter and median")
abline(v=0); abline(h=0)
#  draw the barycenter and the median
points(run_bary$support, col="red", pch=19)
points(run_median$support, col="blue", pch=19)
par(opar)
#-------------------------------------------------------------------
#     Free-Support Wasserstein Median of Multiple Gaussians
#
# * class 1 : samples from N((0,0),  Id)
# * class 2 : samples from N((20,0), Id)
#
#  We draw 8 empirical measures of size 50 from class 1, and
#  2 from class 2. All measures have uniform weights.
#-------------------------------------------------------------------
## GENERATE DATA
#  8 empirical measures from class 1
input_measures = vector("list", length=10L)
for (i in 1:8){
input_measures[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in 9:10){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 20
input_measures[[j]] = base_draw
}
## COMPUTE
#  compute the Wasserstein median
run_median = rmedPF(input_measures, num_support = 50)
#  compute the Wasserstein barycenter
run_bary   = rbaryGD(input_measures, num_support = 50)
## VISUALIZE
opar <- par(no.readonly=TRUE)
#  draw the base points of two classes
base_1 = matrix(rnorm(80*2), ncol=2)
base_2 = matrix(rnorm(20*2), ncol=2)
base_2[,1] = base_2[,1] + 20
base_mat = rbind(base_1, base_2)
plot(base_mat, col="gray80", pch=19)
#  auxiliary information
title("estimated barycenter and median")
abline(v=0); abline(h=0)
#  draw the barycenter and the median
points(run_bary$support, col="red", pch=19)
points(run_median$support, col="blue", pch=19)
par(opar)
idx = seq_len(10)
prob = abs(rnorm(10)); prob = prob/sum(prob)
prob
sample(idx, prob, replace=TRUE)
sample(idx, length(idx), replace=TRUE, prob = prob)
# sampling
seq_len(10)
sample_x = sample(idx, length(idx), replace=TRUE, prob = prob)
table(sample_x)
names(table(sample_x))
round(names(table(sample_x)))
as.numeric(names(table(sample_x)))
tablle_x
table_x
sample_x
# tabularize
table_x = table(sample_x)
select_x = as.numeric(table_x)
table_x
select_x
select_x = as.numeric(names(table_x))
select_y = as.numeric(names(table_y))
table_x
select_x
as.vector(table_x)
m = 20
n = 10
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boot100 = wassboot(X, Y, B=100)
m = 20
n = 10
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boot100 = wassboot(X, Y, B=100)
#  Boostrapping Wasserstein Distance between Two Bivariate Normals
#
# * class 1 : samples from Gaussian with mean=(-5, 0)
# * class 2 : samples from Gaussian with mean=(+5, 0)
#-------------------------------------------------------------------
## SMALL EXAMPLE
m = 20
n = 10
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boot100 = wassboot(X, Y, B=100)
boot100$distance
hist(boot100$boot_samples)
hist(boot100$boot_samples, xlab="Estimates", main="Bootstrapping")
abline(v=boot100$distance, lwd=2, col="red")
help(legend)
opar <- par(no.readonly=TRUE)
hist(boot100$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boot100$distance, lwd=2, col="blue")
abline(v=mean(boot100$boot_samples), lwd=2, col="red")
legend("topright", c("estimate","posterior mean"), col=c("blue","red"), lwd=2)
par(opar)
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
## VISUALIZE
opar <- par(no.readonly=TRUE)
hist(boot100$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boot100$distance, lwd=2, col="blue")
abline(v=mean(boot100$boot_samples), lwd=2, col="red")
abline(v=10, col="cyan", lwd=2)
legend("topright", c("grouth truth,"estimate","posterior mean"),
col=c("cyan","blue","red"), lwd=2)
legend("topright", c("ground truth","estimate","posterior mean"),
col=c("cyan","blue","red"), lwd=2)
# * class 2 : samples from Gaussian with mean=(+5, 0)
#-------------------------------------------------------------------
## SMALL EXAMPLE
m = round(runif(1, min=50, max=100))
n = round(runif(1, min=50, max=100))
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boots = wassboot(X, Y, B=1000)
## VISUALIZE
opar <- par(no.readonly=TRUE)
hist(boots$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boots$distance, lwd=2, col="blue")
abline(v=mean(boots$boot_samples), lwd=2, col="red")
abline(v=10, col="cyan", lwd=2)
legend("topright", c("ground truth","estimate","posterior mean"),
col=c("cyan","blue","red"), lwd=2)
par(opar)
legend("topright", c("ground truth","estimate","bootstrap mean"),
opar <- par(no.readonly=TRUE)
hist(boots$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boots$distance, lwd=2, col="blue")
opar <- par(no.readonly=TRUE)
hist(boots$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boots$distance, lwd=2, col="blue")
abline(v=mean(boots$boot_samples), lwd=2, col="red")
abline(v=10, col="cyan", lwd=2)
legend("topright", c("ground truth","estimate","bootstrap mean"),
col=c("cyan","blue","red"), lwd=2)
9/(32*sqrt(2)) - 1/32
1/16
q()
m = sample(100:200, 1)
n = sample(100:200, 1)
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
Z = Y%*%qr.Q(qr(matrix(rnorm(4), ncol=2)))
sqrt(8)
wasserstein(X, Y)$distance
wasserstein(X, Z)$distance
pwdist(X, Y)$distance
pwdist(X, Z)$distance
pkgdown::build_site()
pkgdown::build_site()
