#  prepare empty lists
inputs = vector("list", length=30L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 11:20){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+10]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, main="Regular Wasserstein Distance")
image(dist_PW, main="Procrustes-Wasserstein distance")
par(opar)
#  the regular Wasserstein and PW distance.
#-------------------------------------------------------------------
## GENERATE DATA
set.seed(10)
#  prepare empty lists
inputs = vector("list", length=15L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:5){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 6:10){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+5]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(15, 15))
dist_PW = array(0, c(15, 15))
#  compute pairwise distances
for (i in 1:14){
for (j in (i+1):15){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, main="Regular Wasserstein Distance")
image(dist_PW, main="Procrustes-Wasserstein distance")
par(opar)
image(dist_RW, xaxt="", yaxt="", main="Regular Wasserstein Distance")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein Distance")
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein Distance")
image(dist_PW, xaxt="n", yaxt="n", main="Procrustes-Wasserstein distance")
par(opar)
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
par(opar)
graphics.off()
rm(list=ls())
p_male = dnorm(172, mean=178.63, sd=3.47)
p_female = dnorm(172, mean=170.27, sd=3.91)
p_male/(p_male + p_female)
help(pwdist)
#  prepare empty lists
inputs = vector("list", length=30L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 11:30){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+10]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
par(opar)
#-------------------------------------------------------------------
## GENERATE DATA
set.seed(10)
#  prepare empty lists
inputs = vector("list", length=30L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 11:30){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+10]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
par(opar)
pkgdown::build_site()
## GENERATE DATA
set.seed(10)
#  prepare empty lists
n = 5
inputs = vector("list", length=3*n)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:n){
inputs[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in (n+1):(2*n)){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+n]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(3*n, 3*n))
dist_PW = array(0, c(3*n, 3*n))
#  compute pairwise distances
for (i in 1:(3*n-1)){
for (j in (i+1):(3*n)){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
par(opar)
}
rm(list=ls())
graphics.off()
X = as.matrix(iris[,1:4])
pair_D = as.matrix(stats::dist(X))
upper.tri(par_D)
upper.tri(pair_D)
upp_tri = pair_D[upper.tri(pair_D)]
length(upp_tri)
# Degree vector and unnormalized Laplacian
deg <- rowSums(W)
sigma = stats::median(as.vector(pair_D[upper.tri(pair_D)]))
W = exp(- (pair_D^2) / (2*sigma^2)) # affinity matrix
# Degree vector and unnormalized Laplacian
deg <- rowSums(W)
L   <- diag(deg) - W
# Eigen-decomposition (L is symmetric)
eig <- eigen(L, symmetric = TRUE)
# Sort eigenvalues ascending
ord    <- order(eig$values)
vals   <- eig$values[ord]
vecs   <- eig$vectors[, ord, drop = FALSE]
vals
X = as.matrix(iris[,1:4])
# PCA preprocessing
X2d = eigen(cov(X))
X2d
# PCA preprocessing
X2d = X%*%eigen(cov(X))$vectors[,1:2]
# compute fiedler vector
fied_vec = fiedler(X2d, normalize=TRUE)
# compute fiedler vector
fied_vec = fiedler(X2d, normalize=TRUE)
# plot
opar <- par(no.readonly=TRUE)
plot(X2d, col=rainbow(150)[as.numeric(cut(fied_vec, breaks=150))], pch=19,
main="Fiedler vector on Iris dataset (PCA-reduced)")
par(opar)
# plot
opar <- par(no.readonly=TRUE)
plot(X2d, col=rainbow(150)[as.numeric(cut(fied_vec, breaks=150))],
pch=19, xlab="PC 1", ylab="PC 2",
main="Fiedler vector on Iris dataset (PCA-reduced)")
par(opar)
pkgdown::build_site()
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
plan_R
image(plan_R)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
m = 200
n = 1000
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
m = 500
n = 500
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
microbenchmark::microbenchmark(plan_R = compare_two(X, Y, useR=TRUE),
plan_C = compare_two(X, Y, useR=FALSE),
times=10)
warnings()
m = 200
n = 300
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
microbenchmark::microbenchmark(plan_R = compare_two(X, Y, useR=TRUE),
plan_C = compare_two(X, Y, useR=FALSE),
times=10)
m = 200
n = 300
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
microbenchmark::microbenchmark(plan_R = compare_two(X, Y, useR=TRUE),
plan_C = compare_two(X, Y, useR=FALSE),
times=10)
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
plan_C
m = 200
n = 300
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
a
m = 200
n = 300
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
X
Y
m = 200
n = 300
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
m = 10
n = 20
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
m = 100
n = 150
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
m = 3000
m = 300
n = 150
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
plan_R = compare_two(X, Y, useR=TRUE)
plan_C = compare_two(X, Y, useR=FALSE)
par(mfrow=c(1,2))
image(plan_R, main="lpSolve")
image(plan_C, main="Bonneel")
norm(plan_R - plan_C, "F")
microbenchmark::microbenchmark(
plan_R = compare_two(X, Y, useR=TRUE),
plan_C = compare_two(X, Y, useR=FALSE),
times=5L
)
## GENERATE DATA
set.seed(10)
#  prepare empty lists
inputs = vector("list", length=30)
#  generate class 1 and 2
iris_mat = as.matrix(iris[sample(1:150,20),1:4])
for (i in 1:10){
inputs[[i]] = iris_mat + matrix(rnorm(20*4), ncol=4)
inputs[[i+10]] = inputs[[i]]%*%qr.Q(qr(matrix(runif(16), ncol=4)))
}
#  generate class 3
for (j in 21:30){
inputs[[j]] = matrix(rnorm(20*4), ncol=4)
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_GW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
X <- inputs[[i]]
Dx <- stats::dist(X)
for (j in (i+1):30){
Y <- inputs[[j]]
Dy <- stats::dist(Y)
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(X, Y)$distance
dist_GW[i,j] <- dist_GW[j,i] <- gwdist(dist(Dx, Dy)$distance
}
#  compute pairwise distances
for (i in 1:29){
X <- inputs[[i]]
Dx <- stats::dist(X)
for (j in (i+1):30){
Y <- inputs[[j]]
Dy <- stats::dist(Y)
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(X, Y)$distance
dist_GW[i,j] <- dist_GW[j,i] <- gwdist(Dx, Dy)$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_GW, xaxt="n", yaxt="n", main="Gromov-Wasserstein distance")
par(opar)
pkgdown::build_site()
pkgdown::build_site()
library(maotai)
maotai::cmds()
help(cmds)
all_mean = rep(0, 2)
all_cov  = matrix(0, nrow=2, ncol=2)
all_mean
all_cov
data(digits)
i=1
hey = img2measure(digit3[[i]])$support
data(digit3)
n = 5
data_D = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])$support
}
hey
hey = img2measure(digit3[[i]])
data(digit3)
n = 5
data_D = vector("list", length=n)
data_W = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])
data_D[[i]] = stats::dist(hey$support)
data_W[[i]] = as.vector(hey$weight)
}
computed <- gwbary(data_D, marginals=data_W, num_support=50, method="mm", maxiter=20)
data(digit3)
n = 5
data_D = vector("list", length=n)
data_W = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])
data_D[[i]] = stats::dist(hey$support)
data_W[[i]] = as.vector(hey$weight)
}
computed <- gwbary(data_D, marginals=data_W, num_support=50, method="mm", maxiter=20)
computed
computed <- gwbary(data_D, marginals=data_W, num_support=50, method="mm", maxiter=20)
data(digit3)
n = 5
data_D = vector("list", length=n)
data_W = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])
data_D[[i]] = stats::dist(hey$support)
data_W[[i]] = as.vector(hey$weight)
}
computed <- gwbary(data_D, marginals=data_W, num_support=50, method="mm", maxiter=20)
data(digit3)
n = 5
data_D = vector("list", length=n)
data_W = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])
data_D[[i]] = stats::dist(hey$support)
data_W[[i]] = as.vector(hey$weight)
}
computed <- gwbary(data_D, marginals=data_W, num_support=50, method="mm", maxiter=20)
computed
DD = computed$weight
plot(cmdscale(DD))
class(DD)
DD
DD = computed$dist
plot(cmdscale(DD))
rm(list=ls())
graphics.off()
data(digit3)
n = 5
data_D = vector("list", length=n)
data_W = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])
data_D[[i]] = stats::dist(hey$support)
data_W[[i]] = as.vector(hey$weight)
}
computed <- gwbary(data_D, marginals=data_W, num_support=50, method="mm", maxiter=3)
hey = cmdscale(computed$dist)
plot(hey[,1], hey[,2], pch=19)
data(digit3)
n = 5
data_D = vector("list", length=n)
data_W = vector("list", length=n)
for (i in 1:n){
hey = img2measure(digit3[[i]])
data_D[[i]] = stats::dist(hey$support)
data_W[[i]] = as.vector(hey$weight)
}
computed <- gwbary(data_D, marginals=data_W, num_support=100, method="mm", maxiter=5)
plot(cmdscale(computed$dist), pch=19)
graphics.off()
system("R CMD config SHLIB_OPENMP_CXXFLAGS")
Sys.getenv("SHLIB_OPENMP_CXXFLAGS")
graphics.off()
