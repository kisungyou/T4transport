input_measures = vector("list", length=10L)
for (i in 1:8){
input_measures[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in 9:10){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 20
input_measures[[j]] = base_draw
}
## COMPUTE
#  compute the Wasserstein median
run_median = rmedPF(input_measures, num_support = 50)
#  compute the Wasserstein barycenter
run_bary   = rbaryGD(input_measures, num_support = 50)
## VISUALIZE
opar <- par(no.readonly=TRUE)
#  draw the base points of two classes
base_1 = matrix(rnorm(80*2), ncol=2)
base_2 = matrix(rnorm(20*2), ncol=2)
base_2[,1] = base_2[,1] + 20
base_mat = rbind(base_1, base_2)
plot(base_mat, col="gray80", pch=19)
#  auxiliary information
title("estimated barycenter and median")
abline(v=0); abline(h=0)
#  draw the barycenter and the median
points(run_bary$support, col="red", pch=19)
points(run_median$support, col="blue", pch=19)
par(opar)
idx = seq_len(10)
prob = abs(rnorm(10)); prob = prob/sum(prob)
prob
sample(idx, prob, replace=TRUE)
sample(idx, length(idx), replace=TRUE, prob = prob)
# sampling
seq_len(10)
sample_x = sample(idx, length(idx), replace=TRUE, prob = prob)
table(sample_x)
names(table(sample_x))
round(names(table(sample_x)))
as.numeric(names(table(sample_x)))
tablle_x
table_x
sample_x
# tabularize
table_x = table(sample_x)
select_x = as.numeric(table_x)
table_x
select_x
select_x = as.numeric(names(table_x))
select_y = as.numeric(names(table_y))
table_x
select_x
as.vector(table_x)
m = 20
n = 10
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boot100 = wassboot(X, Y, B=100)
m = 20
n = 10
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boot100 = wassboot(X, Y, B=100)
#  Boostrapping Wasserstein Distance between Two Bivariate Normals
#
# * class 1 : samples from Gaussian with mean=(-5, 0)
# * class 2 : samples from Gaussian with mean=(+5, 0)
#-------------------------------------------------------------------
## SMALL EXAMPLE
m = 20
n = 10
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boot100 = wassboot(X, Y, B=100)
boot100$distance
hist(boot100$boot_samples)
hist(boot100$boot_samples, xlab="Estimates", main="Bootstrapping")
abline(v=boot100$distance, lwd=2, col="red")
help(legend)
opar <- par(no.readonly=TRUE)
hist(boot100$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boot100$distance, lwd=2, col="blue")
abline(v=mean(boot100$boot_samples), lwd=2, col="red")
legend("topright", c("estimate","posterior mean"), col=c("blue","red"), lwd=2)
par(opar)
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
## VISUALIZE
opar <- par(no.readonly=TRUE)
hist(boot100$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boot100$distance, lwd=2, col="blue")
abline(v=mean(boot100$boot_samples), lwd=2, col="red")
abline(v=10, col="cyan", lwd=2)
legend("topright", c("grouth truth,"estimate","posterior mean"),
col=c("cyan","blue","red"), lwd=2)
legend("topright", c("ground truth","estimate","posterior mean"),
col=c("cyan","blue","red"), lwd=2)
# * class 2 : samples from Gaussian with mean=(+5, 0)
#-------------------------------------------------------------------
## SMALL EXAMPLE
m = round(runif(1, min=50, max=100))
n = round(runif(1, min=50, max=100))
X = matrix(rnorm(m*2), ncol=2) # m obs. for X
Y = matrix(rnorm(n*2), ncol=2) # n obs. for Y
X[,1] = X[,1] - 5
Y[,1] = Y[,1] + 5
## COMPUTE THE BOOTSTRAP SAMPLES
boots = wassboot(X, Y, B=1000)
## VISUALIZE
opar <- par(no.readonly=TRUE)
hist(boots$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boots$distance, lwd=2, col="blue")
abline(v=mean(boots$boot_samples), lwd=2, col="red")
abline(v=10, col="cyan", lwd=2)
legend("topright", c("ground truth","estimate","posterior mean"),
col=c("cyan","blue","red"), lwd=2)
par(opar)
legend("topright", c("ground truth","estimate","bootstrap mean"),
opar <- par(no.readonly=TRUE)
hist(boots$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boots$distance, lwd=2, col="blue")
opar <- par(no.readonly=TRUE)
hist(boots$boot_samples, xlab="Estimates", main="Bootstrap Samples")
abline(v=boots$distance, lwd=2, col="blue")
abline(v=mean(boots$boot_samples), lwd=2, col="red")
abline(v=10, col="cyan", lwd=2)
legend("topright", c("ground truth","estimate","bootstrap mean"),
col=c("cyan","blue","red"), lwd=2)
9/(32*sqrt(2)) - 1/32
1/16
q()
m = sample(100:200, 1)
n = sample(100:200, 1)
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y
Z = Y%*%qr.Q(qr(matrix(rnorm(4), ncol=2)))
sqrt(8)
wasserstein(X, Y)$distance
wasserstein(X, Z)$distance
pwdist(X, Y)$distance
pwdist(X, Z)$distance
pkgdown::build_site()
pkgdown::build_site()
seq_len(100)
help(norm)
help(pwbary)
help(pwbary)
random_rot = qr.Q(qr(matrix(rnorm(4), ncol=2)))
random_rot
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
random_rot
set.seed(10)
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
random_rot
#  prepare empty lists
input_1 = vector("list", length=10L)
input_2 = vector("list", length=10L)
input_3 = vector("list", length=10L)
#  generate
set.seed(10)
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
input_1[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in 1:10){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 20
input_2[[j]] = base_draw
input_3[[j]] = base_draw%*%random_rot
}
## COMPUTE
#  regular Wasserstein barycenters
regular_1 = rbaryGD(input_1)
regular_1 = rbaryGD(input_1, num_support=50)
regular_2 = rbaryGD(input_2, num_support=50)
regular_3 = rbaryGD(input_3, num_support=50)
#  Procrustes-Wasserstein barycenters
pw_1 = pwbary(input_1, num_support=50)
pw_2 = pwbary(input_2, num_support=50)
pw_3 = pwbary(input_3, num_support=50)
regular_1$support
opar <- par(no.readonly=TRUE)
par(mfrow=c(2,1))
#  first plot: draw the base points of two classes
base_1 = matrix(rnorm(80*2), ncol=2)
base_2 = matrix(rnorm(20*2), ncol=2)
base_2[,1] = base_2[,1] + 20
base_mat = rbind(base_1, base_2)
plot(base_mat, col="gray80", pch=19)
regular_1$support
points(regular_1$support, pch=19, col="blue")
points(regular_1$support, pch=19, cex=0.5, col="blue")
points(regular_2$support, pch=19, cex=0.5, col="red")
points(regular_3$support, pch=19, cex=0.5, col="cyan")
regular_3$support
graphics.off()
min(regular_1$support)
apply(regular_1$support, 1, min)
apply(regular_1$support, 2, min)
apply(regular_2$support, 2, min)
apply(regular_3$support, 2, min)
# * class 3 : samples from N((20,0), Id) randomly rotated
#
#  We draw 10 empirical measures from each and compare
#  their barycenters under the regular and PW geometries.
#-------------------------------------------------------------------
## GENERATE DATA
set.seed(10)
#  prepare empty lists
input_1 = vector("list", length=10L)
input_2 = vector("list", length=10L)
input_3 = vector("list", length=10L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
input_1[[i]] = matrix(rnorm(50*2), ncol=2)
}
for (j in 1:10){
base_draw = matrix(rnorm(50*2), ncol=2)
base_draw[,1] = base_draw[,1] + 20
input_2[[j]] = base_draw
input_3[[j]] = base_draw%*%random_rot
}
## COMPUTE
#  regular Wasserstein barycenters
regular_1 = rbaryGD(input_1, num_support=50)
regular_2 = rbaryGD(input_2, num_support=50)
regular_3 = rbaryGD(input_3, num_support=50)
#  Procrustes-Wasserstein barycenters
pw_1 = pwbary(input_1, num_support=50)
pw_2 = pwbary(input_2, num_support=50)
pw_3 = pwbary(input_3, num_support=50)
par(mfrow=c(3,1))
#  set the x- and y-limits for display
#  plot prototypical measures per class
plot(input_1[[1]], pch=19, cex=0.5, col="gray80",
main="3 types of measures", xlab="", ylab="")
points(input_2[[1]], pch=19, cex=0.5, col="gray50")
points(input_3[[1]], pch=19, cex=0.5m col="gray10")
points(input_3[[1]], pch=19, cex=0.5, col="gray10")
apply(regular_1$support, 2, min)
apply(regular_2$support, 2, min)
apply(regular_3$support, 2, min)
rbind(apply(regular_1$support, 2, min),
apply(regular_2$support, 2, min),
apply(regular_3$support, 2, min))
rbind(apply(regular_1$support, 2, max),
apply(regular_2$support, 2, max),
apply(regular_3$support, 2, max))
lim_x = c(-25, 25)
lim_y = c(-15, 5)
#  plot prototypical measures per class
plot(input_1[[1]], pch=19, cex=0.5, col="gray80",
main="3 types of measures", xlab="", ylab="")
points(input_2[[1]], pch=19, cex=0.5, col="gray50")
points(input_3[[1]], pch=19, cex=0.5, col="gray10")
#  plot regular barycenters
graphics.off()
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(3,1))
#  set the x- and y-limits for display
lim_x = c(-25, 25)
lim_y = c(-15, 5)
#  plot prototypical measures per class
plot(input_1[[1]], pch=19, cex=0.5, col="gray80",
main="3 types of measures", xlab="", ylab="",
xlim=lim_x, ylim=lim_y)
points(input_2[[1]], pch=19, cex=0.5, col="gray50")
points(input_3[[1]], pch=19, cex=0.5, col="gray10")
#  plot regular barycenters
plot(regular_1$support, pch=19, cex=0.5, col="blue",
main="Regular Wasserstein barycenters",
xlab="", ylab="", xlim=lim_x, ylim=lim_y)
points(regular_2$support, pch=19, cex=0.5, col="cyan")
points(regular_3$support, pch=19, cex=0.5, col="red")
#  plot PW barycenters
plot(pw_1$support, pch=19, cex=0.5, col="blue",
main="Procrustes-Wasserstein barycenters",
xlab="", ylab="", xlim=lim_x, ylim=lim_y)
points(pw_2$support, pch=19, cex=0.5, col="cyan")
points(pw_3$support, pch=19, cex=0.5, col="red")
par(opar)
help(rnorm)
## GENERATE DATA
set.seed(10)
#  prepare empty lists
input_1 = vector("list", length=10L)
input_2 = vector("list", length=10L)
input_3 = vector("list", length=10L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
input_1[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 1:10){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
input_2[[j]] = base_draw
input_3[[j]] = base_draw%*%random_rot
}
## COMPUTE
#  regular Wasserstein barycenters
regular_1 = rbaryGD(input_1, num_support=50)
regular_2 = rbaryGD(input_2, num_support=50)
regular_3 = rbaryGD(input_3, num_support=50)
#  Procrustes-Wasserstein barycenters
pw_1 = pwbary(input_1, num_support=50)
pw_2 = pwbary(input_2, num_support=50)
pw_3 = pwbary(input_3, num_support=50)
apply(rbind(apply(regular_1$support, 2, min),
apply(regular_2$support, 2, min),
apply(regular_3$support, 2, min)), 2, min)
apply(rbind(apply(regular_1$support, 2, max),
apply(regular_2$support, 2, max),
apply(regular_3$support, 2, max)), 2, max)
opar <- par(no.readonly=TRUE)
par(mfrow=c(3,1))
#  set the x- and y-limits for display
lim_x = c(-12, 12)
lim_y = c(-10, 5)
#  plot prototypical measures per class
plot(input_1[[1]], pch=19, cex=0.5, col="gray80",
main="3 types of measures", xlab="", ylab="",
xlim=lim_x, ylim=lim_y)
points(input_2[[1]], pch=19, cex=0.5, col="gray50")
points(input_3[[1]], pch=19, cex=0.5, col="gray10")
#  plot regular barycenters
plot(regular_1$support, pch=19, cex=0.5, col="blue",
main="Regular Wasserstein barycenters",
xlab="", ylab="", xlim=lim_x, ylim=lim_y)
points(regular_2$support, pch=19, cex=0.5, col="cyan")
points(regular_3$support, pch=19, cex=0.5, col="red")
#  plot PW barycenters
plot(pw_1$support, pch=19, cex=0.5, col="blue",
main="Procrustes-Wasserstein barycenters",
xlab="", ylab="", xlim=lim_x, ylim=lim_y)
points(pw_2$support, pch=19, cex=0.5, col="cyan")
points(pw_3$support, pch=19, cex=0.5, col="red")
par(opar)
rm(list=ls())
graphics.off()
help(wasserstein)
#-------------------------------------------------------------------
## GENERATE DATA
set.seed(10)
#  prepare empty lists
inputs = vector("list", length=30L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 1:10){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+10]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] = wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] = pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] = wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] = pwdist(inputs[[i]], inputs[[j]])$distance
}
}
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
Warnings()
inputs[[j]]
inputs[[1]]
inputs[[2]]
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 11:20){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+10]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
rm(list=ls())
## GENERATE DATA
set.seed(10)
#  prepare empty lists
inputs = vector("list", length=30L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:10){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 11:20){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+10]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(30, 30))
dist_PW = array(0, c(30, 30))
#  compute pairwise distances
for (i in 1:29){
for (j in (i+1):30){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, main="Regular Wasserstein Distance")
image(dist_PW, main="Procrustes-Wasserstein distance")
par(opar)
#  the regular Wasserstein and PW distance.
#-------------------------------------------------------------------
## GENERATE DATA
set.seed(10)
#  prepare empty lists
inputs = vector("list", length=15L)
#  generate
random_rot = qr.Q(qr(matrix(runif(4), ncol=2)))
for (i in 1:5){
inputs[[i]] = cbind(rnorm(50, sd=2), rnorm(50, sd=0.5))
}
for (j in 6:10){
base_draw = cbind(rnorm(50, sd=0.5), rnorm(50, sd=2))
base_draw[,1] = base_draw[,1] + 10
inputs[[j]] = base_draw
inputs[[j+5]] = base_draw%*%random_rot
}
## COMPUTE
#  empty arrays
dist_RW = array(0, c(15, 15))
dist_PW = array(0, c(15, 15))
#  compute pairwise distances
for (i in 1:14){
for (j in (i+1):15){
dist_RW[i,j] <- dist_RW[j,i] <- wasserstein(inputs[[i]], inputs[[j]])$distance
dist_PW[i,j] <- dist_PW[j,i] <- pwdist(inputs[[i]], inputs[[j]])$distance
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, main="Regular Wasserstein Distance")
image(dist_PW, main="Procrustes-Wasserstein distance")
par(opar)
image(dist_RW, xaxt="", yaxt="", main="Regular Wasserstein Distance")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein Distance")
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein Distance")
image(dist_PW, xaxt="n", yaxt="n", main="Procrustes-Wasserstein distance")
par(opar)
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(dist_RW, xaxt="n", yaxt="n", main="Regular Wasserstein distance")
image(dist_PW, xaxt="n", yaxt="n", main="PW distance")
par(opar)
graphics.off()
rm(list=ls())
p_male = dnorm(172, mean=178.63, sd=3.47)
p_female = dnorm(172, mean=170.27, sd=3.91)
p_male/(p_male + p_female)
